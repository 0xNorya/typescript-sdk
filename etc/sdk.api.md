## API Report File for "@3rdweb/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { BaseContract } from 'ethers';
import { BigNumber } from 'ethers';
import { BigNumber as BigNumber_2 } from '@ethersproject/bignumber';
import { BigNumberish } from 'ethers';
import { BigNumberish as BigNumberish_2 } from '@ethersproject/bignumber';
import { BytesLike } from 'ethers';
import { CallOverrides } from 'ethers';
import { Coin } from '@3rdweb/contracts';
import { ethers } from 'ethers';
import { LazyMintERC1155 } from '@3rdweb/contracts';
import { LazyMintERC721 } from '@3rdweb/contracts';
import { Log } from '@ethersproject/providers';
import { Marketplace } from '@3rdweb/contracts';
import type { Network } from '@ethersproject/providers';
import { NFTCollection } from '@3rdweb/contracts';
import { Pack } from '@3rdweb/contracts/dist/Pack';
import { Pack as Pack_2 } from '@3rdweb/contracts';
import { Provider } from '@ethersproject/providers';
import { SignatureMint721 } from '@3rdweb/contracts';
import { Signer } from 'ethers';
import { Splits } from '@3rdweb/contracts';
import { ThirdwebRegistry } from '@3rdweb/contracts';
import { TransactionReceipt } from '@ethersproject/providers';
import { VotingGovernor } from '@3rdweb/contracts';

// @public
export class AdminRoleMissingError extends Error {
    constructor(address?: string, contractAddress?: string, message?: string);
}

// @public (undocumented)
export type AllModuleMetadata = CollectionModuleMetadata | CommonModuleMetadata;

// Warning: (ae-forgotten-export) The symbol "RegistryModule" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "AnyContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type AnyContract = typeof BundleCollectionModule | typeof NFTModule | typeof PackModule | typeof DropModule | typeof SplitsModule | typeof BundleDropModule | typeof MarketplaceModule | typeof TokenModule | typeof RegistryModule | typeof VoteModule;

// @public (undocumented)
export class AssetNotFoundError extends Error {
    // @internal
    constructor(message?: string);
}

// @public
export class AuctionAlreadyStartedError extends Error {
    constructor(id?: string);
}

// @public
export class AuctionHasNotEndedError extends Error {
    constructor(id?: string, endTime?: BigNumberish);
}

// @public
export interface AuctionListing {
    asset: NFTMetadata;
    assetContractAddress: string;
    buyoutCurrencyValuePerToken: CurrencyValue;
    buyoutPrice: BigNumberish;
    currencyContractAddress: string;
    endTimeInEpochSeconds: BigNumberish;
    id: string;
    quantity: BigNumberish;
    reservePrice: BigNumberish;
    reservePriceCurrencyValuePerToken: CurrencyValue;
    sellerAddress: string;
    startTimeInEpochSeconds: BigNumberish;
    tokenId: BigNumberish;
    // (undocumented)
    type: ListingType.Auction;
}

// @public
export class BundleCollectionModule extends ModuleWithRoles<NFTCollection> implements ITransferable {
    // (undocumented)
    balance(tokenId: string): Promise<BigNumber_2>;
    balanceOf(address: string, tokenId: string): Promise<BigNumber_2>;
    burn(args: INFTBundleBatchArgs): Promise<TransactionReceipt>;
    // (undocumented)
    burnBatch(args: INFTBundleBatchArgs[]): Promise<TransactionReceipt>;
    // (undocumented)
    burnBatchFrom(account: string, args: INFTBundleBatchArgs[]): Promise<TransactionReceipt>;
    // (undocumented)
    burnFrom(account: string, args: INFTBundleBatchArgs): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): NFTCollection;
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "BundleMetadata" which is marked as @beta
    //
    // (undocumented)
    create(metadata: MetadataURIOrObject): Promise<BundleMetadata>;
    // Warning: (ae-incompatible-release-tags) The symbol "createAndMint" is marked as @public, but its signature references "INFTBundleCreateArgs" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "createAndMint" is marked as @public, but its signature references "BundleMetadata" which is marked as @beta
    createAndMint(metadataWithSupply: INFTBundleCreateArgs): Promise<BundleMetadata>;
    // Warning: (ae-incompatible-release-tags) The symbol "createAndMintBatch" is marked as @public, but its signature references "INFTBundleCreateArgs" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "createAndMintBatch" is marked as @public, but its signature references "BundleMetadata" which is marked as @beta
    createAndMintBatch(metadataWithSupply: INFTBundleCreateArgs[]): Promise<BundleMetadata[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "createBatch" is marked as @public, but its signature references "BundleMetadata" which is marked as @beta
    //
    // (undocumented)
    createBatch(metadatas: MetadataURIOrObject[]): Promise<BundleMetadata[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "createWithErc20" is marked as @public, but its signature references "INFTBundleCreateArgs" which is marked as @beta
    //
    // (undocumented)
    createWithErc20(tokenContract: string, tokenAmount: BigNumberish_2, args: INFTBundleCreateArgs): Promise<void>;
    // (undocumented)
    createWithERC721(tokenContract: string, tokenId: BigNumberish_2, metadata: MetadataURIOrObject): Promise<void>;
    // (undocumented)
    createWithNFT(tokenContract: string, tokenId: BigNumberish_2, metadata: MetadataURIOrObject): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "createWithToken" is marked as @public, but its signature references "INFTBundleCreateArgs" which is marked as @beta
    //
    // (undocumented)
    createWithToken(tokenContract: string, tokenAmount: BigNumberish_2, args: INFTBundleCreateArgs): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "get" is marked as @public, but its signature references "BundleMetadata" which is marked as @beta
    get(tokenId: string, address?: string): Promise<BundleMetadata>;
    // Warning: (ae-incompatible-release-tags) The symbol "getAll" is marked as @public, but its signature references "BundleMetadata" which is marked as @beta
    getAll(address?: string): Promise<BundleMetadata[]>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // Warning: (ae-incompatible-release-tags) The symbol "getOwned" is marked as @public, but its signature references "BundleMetadata" which is marked as @beta
    getOwned(_address?: string): Promise<BundleMetadata[]>;
    getRoyaltyBps(): Promise<BigNumberish_2>;
    getRoyaltyRecipientAddress(): Promise<string>;
    // (undocumented)
    isApproved(address: string, operator: string, assetContract?: string, assetId?: BigNumberish_2): Promise<boolean>;
    // (undocumented)
    isTransferRestricted(): Promise<boolean>;
    // (undocumented)
    mint(args: INFTBundleBatchArgs): Promise<void>;
    // (undocumented)
    mintBatch(args: INFTBundleBatchArgs[]): Promise<void>;
    // (undocumented)
    mintBatchTo(to: string, args: INFTBundleBatchArgs[], data?: BytesLike): Promise<void>;
    // (undocumented)
    mintTo(to: string, args: INFTBundleBatchArgs, data?: BytesLike): Promise<void>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    transfer(to: string, tokenId: string, amount: BigNumberish_2): Promise<TransactionReceipt>;
    transferBatchFrom(from: string, to: string, args: INFTBundleBatchArgs[], data?: BytesLike): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, args: INFTBundleBatchArgs, data?: BytesLike): Promise<TransactionReceipt>;
    // (undocumented)
    unwrapNFT(tokenId: BigNumberish_2): Promise<TransactionReceipt>;
    // (undocumented)
    unwrapToken(tokenId: BigNumberish_2, amount: BigNumberish_2): Promise<TransactionReceipt>;
}

// @beta (undocumented)
export interface BundleDropCreateClaimCondition {
    // (undocumented)
    currency?: string;
    // (undocumented)
    maxClaimableSupply: BigNumberish;
    // (undocumented)
    merkleRoot?: BytesLike;
    // (undocumented)
    pricePerToken?: BigNumberish;
    // (undocumented)
    quantityLimitPerTransaction?: BigNumberish;
    // (undocumented)
    startTimestamp?: BigNumberish;
    // (undocumented)
    waitTimeInSecondsBetweenClaims?: BigNumberish;
}

// @beta (undocumented)
export interface BundleDropMetadata {
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    supply: BigNumber;
}

// @public
export class BundleDropModule extends ModuleWithRoles<LazyMintERC1155> implements ITransferable {
    // (undocumented)
    balance(tokenId: BigNumberish): Promise<BigNumber>;
    balanceOf(address: string, tokenId: BigNumberish): Promise<BigNumber>;
    // (undocumented)
    burn(tokenId: BigNumberish, amount: BigNumberish): Promise<TransactionReceipt>;
    // (undocumented)
    canClaim(tokenId: BigNumberish, quantity: BigNumberish, addressToCheck?: string): Promise<boolean>;
    claim(tokenId: BigNumberish, quantity: BigNumberish, proofs?: BytesLike[]): Promise<void>;
    claimTo(tokenId: BigNumberish, quantity: BigNumberish, addressToClaim: string, proofs?: BytesLike[]): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): LazyMintERC1155;
    createBatch(metadatas: MetadataURIOrObject[]): Promise<string[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "get" is marked as @public, but its signature references "BundleDropMetadata" which is marked as @beta
    //
    // (undocumented)
    get(tokenId: string): Promise<BundleDropMetadata>;
    // Warning: (ae-incompatible-release-tags) The symbol "getActiveClaimCondition" is marked as @public, but its signature references "ClaimCondition" which is marked as @beta
    //
    // (undocumented)
    getActiveClaimCondition(tokenId: BigNumberish): Promise<ClaimCondition>;
    // Warning: (ae-incompatible-release-tags) The symbol "getAll" is marked as @public, but its signature references "BundleDropMetadata" which is marked as @beta
    getAll(): Promise<BundleDropMetadata[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "getAllClaimConditions" is marked as @public, but its signature references "ClaimCondition" which is marked as @beta
    //
    // (undocumented)
    getAllClaimConditions(tokenId: BigNumberish): Promise<ClaimCondition[]>;
    // @beta
    getAllClaimerAddresses(tokenId: BigNumberish): Promise<string[]>;
    getClaimConditionFactory(): ClaimConditionFactory;
    // (undocumented)
    getClaimConditionsFactory(): ClaimConditionFactory;
    getClaimIneligibilityReasons(tokenId: BigNumberish, quantity: BigNumberish, addressToCheck?: string): Promise<ClaimEligibility[]>;
    // (undocumented)
    getDefaultSaleRecipient(): Promise<string>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // Warning: (ae-incompatible-release-tags) The symbol "getOwned" is marked as @public, but its signature references "BundleDropMetadata" which is marked as @beta
    getOwned(_address?: string): Promise<BundleDropMetadata[]>;
    getRoyaltyBps(): Promise<BigNumberish>;
    getRoyaltyRecipientAddress(): Promise<string>;
    // (undocumented)
    getSaleRecipient(tokenId: BigNumberish): Promise<string>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    isTransferRestricted(): Promise<boolean>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "minter", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    setClaimCondition(tokenId: BigNumberish, factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    // (undocumented)
    setDefaultSaleRecipient(recipient: string): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    // (undocumented)
    setSaleRecipient(tokenId: BigNumberish, recipient: string): Promise<TransactionReceipt>;
    totalSupply(tokenId: BigNumberish): Promise<BigNumber>;
    transfer(to: string, tokenId: BigNumberish, amount: BigNumberish, data?: BytesLike): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, tokenId: BigNumberish, amount: BigNumberish, data?: BytesLike): Promise<TransactionReceipt>;
    // (undocumented)
    updateClaimConditions(tokenId: BigNumberish, factory: ClaimConditionFactory): Promise<TransactionReceipt>;
}

// @public (undocumented)
export class BundleDropModuleMetadata extends CommonModuleMetadata {
    platformFeeBPS?: number | undefined;
    // (undocumented)
    platformFeeRecipient: string;
    primarySaleRecipient: string;
    royaltyBPS?: number | undefined;
    royaltyReceipient?: string;
}

// @beta (undocumented)
export interface BundleMetadata {
    // (undocumented)
    creator: string;
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    ownedByAddress: BigNumber_2;
    // (undocumented)
    supply: BigNumber_2;
    // (undocumented)
    underlyingType: UnderlyingType;
}

// @public (undocumented)
export class BundleModuleMetadata extends CommonModuleMetadata {
    feeRecipient?: string;
    sellerFeeBasisPoints: number;
}

// Warning: (ae-internal-missing-underscore) The name "ChainlinkInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ChainlinkInfo = {
    vrfCoordinator: string;
    linkTokenAddress: string;
    keyHash: string;
    fees: BigNumber;
};

// Warning: (ae-internal-missing-underscore) The name "ChainlinkVrf" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const ChainlinkVrf: Record<number, ChainlinkInfo>;

// @beta (undocumented)
export interface ClaimCondition {
    // (undocumented)
    availableSupply: string;
    // (undocumented)
    currency: string;
    // (undocumented)
    currencyContract: string;
    // (undocumented)
    currencyMetadata: CurrencyValue | null;
    // (undocumented)
    currentMintSupply: string;
    // (undocumented)
    maxMintSupply: string;
    // (undocumented)
    merkleRoot: BytesLike;
    // (undocumented)
    price: BigNumber;
    // (undocumented)
    pricePerToken: BigNumber;
    // (undocumented)
    quantityLimitPerTransaction: string;
    // (undocumented)
    startTimestamp: Date;
    // (undocumented)
    waitTimeSecondsLimitPerTransaction: string;
}

// @public (undocumented)
export class ClaimConditionFactory {
    constructor(createSnapshotFunc: (leafs: string[]) => Promise<SnapshotInfo>);
    allSnapshots(): SnapshotInfo[];
    // @internal
    buildConditions(): Promise<PublicClaimCondition[]>;
    // @internal
    buildConditionsForDropV1(): Promise<PublicClaimCondition[]>;
    deleteClaimPhase(index: number): Promise<void>;
    fromPublicClaimConditions(conditions: PublicClaimCondition[]): this;
    newClaimPhase({ startTime, maxQuantity, maxQuantityPerTransaction, }: {
        startTime: Date | number;
        maxQuantity?: BigNumberish;
        maxQuantityPerTransaction?: BigNumberish;
    }): ClaimConditionPhase;
}

// @public (undocumented)
export class ClaimConditionPhase {
    constructor(createSnapshotFunc: (leafs: string[]) => Promise<SnapshotInfo>);
    // @internal
    buildPublicClaimCondition(): Promise<PublicClaimCondition>;
    // @internal (undocumented)
    getSnapshot(): SnapshotInfo | undefined;
    setConditionStartTime(when: Date | number): ClaimConditionPhase;
    setMaxQuantity(maxQuantity: BigNumberish): ClaimConditionPhase;
    setMaxQuantityPerTransaction(max: BigNumberish): ClaimConditionPhase;
    setMerkleRoot(root: string): ClaimConditionPhase;
    setPrice(price: BigNumberish, tokenAddress?: string): ClaimConditionPhase;
    setSnapshot(addresses: string[]): ClaimConditionPhase;
    setWaitTimeBetweenClaims(waitInSeconds: BigNumberish): ClaimConditionPhase;
}

// @public (undocumented)
export enum ClaimEligibility {
    // (undocumented)
    AddressNotAllowed = "This address is not on the allowlist.",
    // (undocumented)
    AlreadyClaimed = "You have already claimed the token.",
    // (undocumented)
    NoActiveClaimPhase = "There is no active claim phase at the moment. Please check back in later.",
    // (undocumented)
    NotEnoughSupply = "There is not enough supply to claim.",
    // (undocumented)
    NotEnoughTokens = "There are not enough tokens in the wallet to pay for the claim.",
    // (undocumented)
    WaitBeforeNextClaimTransaction = "Not enough time since last claim transaction. Please wait."
}

// @public
export class ClaimProof {
    address: string;
    proof: string[];
}

// @public (undocumented)
export interface CollectionMetadata {
    // (undocumented)
    creator: string;
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    ownedByAddress: BigNumber_2;
    // (undocumented)
    supply: BigNumber_2;
}

// @public (undocumented)
export type CollectionModuleMetadata = BundleModuleMetadata;

// @public
export class CommonModuleMetadata {
    description?: string;
    externalLink?: string;
    image?: string | FileOrBuffer;
    name: string;
}

// @public
export interface ContractMetadata {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    description?: string;
    // (undocumented)
    external_link?: string;
    // (undocumented)
    fee_recipient?: string;
    // (undocumented)
    image?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    seller_fee_basis_points?: number;
    // (undocumented)
    uri: string;
}

// @public
export interface Currency {
    // (undocumented)
    decimals: number;
    // (undocumented)
    name: string;
    // (undocumented)
    symbol: string;
}

// @public (undocumented)
export class CurrencyModuleMetadata extends CommonModuleMetadata {
    symbol: string;
}

// @public
export interface CurrencyValue extends Currency {
    // (undocumented)
    displayValue: string;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export class DatastoreModuleMetadata extends CommonModuleMetadata {
}

// Warning: (ae-forgotten-export) The symbol "SUPPORTED_CHAIN_ID" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ChainId" needs to be exported by the entry point index.d.ts
//
// @public
export const DEFAULT_BLOCK_TIMES_FALLBACK: Record<SUPPORTED_CHAIN_ID | ChainId.Hardhat, {
    secondsBetweenBlocks: number;
    synced: boolean;
}>;

// @public
export interface DirectListing {
    asset: NFTMetadata;
    assetContractAddress: string;
    buyoutCurrencyValuePerToken: CurrencyValue;
    buyoutPrice: BigNumberish;
    currencyContractAddress: string;
    id: string;
    quantity: BigNumberish;
    secondsUntilEnd: BigNumberish;
    sellerAddress: string;
    startTimeInSeconds: BigNumberish;
    tokenId: BigNumberish;
    // (undocumented)
    type: ListingType.Direct;
}

// @public
export class DropModule extends ModuleWithRoles<LazyMintERC721> implements ITransferable {
    // @internal
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    // (undocumented)
    balance(): Promise<BigNumber>;
    balanceOf(address: string): Promise<BigNumber>;
    // (undocumented)
    burn(tokenId: BigNumberish): Promise<TransactionReceipt>;
    canClaim(quantity: BigNumberish, addressToCheck?: string): Promise<boolean>;
    // @internal (undocumented)
    canCreateBatch(): Promise<boolean>;
    claim(quantity: BigNumberish, proofs?: BytesLike[]): Promise<NFTMetadataOwner[]>;
    claimTo(quantity: BigNumberish, addressToClaim: string, proofs?: BytesLike[]): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): LazyMintERC721;
    // @beta
    createBatch(metadatas: MetadataURIOrObject[]): Promise<string[]>;
    // (undocumented)
    get(tokenId: string): Promise<NFTMetadataOwner>;
    // Warning: (ae-incompatible-release-tags) The symbol "getActiveClaimCondition" is marked as @public, but its signature references "ClaimCondition" which is marked as @beta
    //
    // (undocumented)
    getActiveClaimCondition(): Promise<ClaimCondition>;
    // Warning: (ae-forgotten-export) The symbol "QueryAllParams" needs to be exported by the entry point index.d.ts
    getAll(queryParams?: QueryAllParams): Promise<NFTMetadataOwner[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "getAllClaimConditions" is marked as @public, but its signature references "ClaimCondition" which is marked as @beta
    //
    // (undocumented)
    getAllClaimConditions(): Promise<ClaimCondition[]>;
    // (undocumented)
    getAllClaimed(queryParams?: QueryAllParams): Promise<NFTMetadataOwner[]>;
    // (undocumented)
    getAllUnclaimed(queryParams?: QueryAllParams): Promise<NFTMetadataOwner[]>;
    getClaimConditionsFactory(): ClaimConditionFactory;
    getClaimIneligibilityReasons(quantity: BigNumberish, addressToCheck?: string): Promise<ClaimEligibility[]>;
    // (undocumented)
    getDefaultSaleRecipient(): Promise<string>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    getOwned(_address?: string): Promise<NFTMetadataOwner[]>;
    getRoyaltyBps(): Promise<BigNumberish>;
    getRoyaltyRecipientAddress(): Promise<string>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    isTransferRestricted(): Promise<boolean>;
    // @internal (undocumented)
    maxTotalSupply(): Promise<BigNumber>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    ownerOf(tokenId: string): Promise<string>;
    // (undocumented)
    static roles: readonly ["admin", "minter", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    setClaimConditions(factory: ClaimConditionFactory): Promise<TransactionReceipt>;
    // (undocumented)
    setDefaultSaleRecipient(recipient: string): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // @internal (undocumented)
    setProviderOrSigner(providerOrSigner: ProviderOrSigner): void;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    // (undocumented)
    totalClaimedSupply(): Promise<BigNumber>;
    // (undocumented)
    totalSupply(): Promise<BigNumber>;
    // (undocumented)
    totalUnclaimedSupply(): Promise<BigNumber>;
    transfer(to: string, tokenId: string): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, tokenId: BigNumberish): Promise<TransactionReceipt>;
    // (undocumented)
    updateClaimConditions(factory: ClaimConditionFactory): Promise<TransactionReceipt>;
}

// @public (undocumented)
export class DropModuleMetadata extends CommonModuleMetadata {
    feeRecipient?: string;
    primarySaleFeeBasisPoints?: number | undefined;
    primarySaleRecipientAddress: string;
    sellerFeeBasisPoints?: number | undefined;
    symbol?: string;
}

// @public (undocumented)
export class DuplicateFileNameError extends Error {
    // @internal
    constructor(fileName: string);
}

// @public
export class DuplicateLeafsError extends Error {
    constructor(message?: string);
}

// @public
export class FetchError extends Error {
    // @internal
    constructor(message: string, innerError?: Error);
    // (undocumented)
    innerError?: Error;
}

// @public (undocumented)
export class FileNameMissingError extends Error {
    // @internal
    constructor();
}

// @public (undocumented)
export type FileOrBuffer = Buffer | File;

// @public
export type ForwardRequestMessage = {
    from: string;
    to: string;
    value: string;
    gas: string;
    nonce: string;
    data: BytesLike;
};

// @public (undocumented)
export class FunctionDeprecatedError extends Error {
    // @internal
    constructor(message: string);
}

// @public
export interface GaslessTransaction {
    // (undocumented)
    callOverrides: CallOverrides;
    // (undocumented)
    chainId: number;
    // (undocumented)
    data: string;
    // (undocumented)
    from: string;
    // (undocumented)
    functionArgs: any[];
    // (undocumented)
    functionName: string;
    // (undocumented)
    gasLimit: BigNumber;
    // (undocumented)
    to: string;
}

// @public
export function generateRoot(items: string[]): string;

// Warning: (ae-internal-missing-underscore) The name "getContractMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getContractMetadata(provider: ProviderOrSigner, address: string, ipfsGatewayUrl: string, resolveGateway?: boolean): Promise<ContractMetadata>;

// Warning: (ae-internal-missing-underscore) The name "getCurrencyBalance" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getCurrencyBalance(providerOrSigner: ProviderOrSigner, tokenAddress: string, walletAddress: string): Promise<CurrencyValue>;

// Warning: (ae-internal-missing-underscore) The name "getCurrencyMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getCurrencyMetadata(providerOrSigner: ProviderOrSigner, asset: string): Promise<Currency>;

// Warning: (ae-internal-missing-underscore) The name "getCurrencyValue" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getCurrencyValue(providerOrSigner: ProviderOrSigner, asset: string, price: BigNumberish): Promise<CurrencyValue>;

// Warning: (ae-internal-missing-underscore) The name "getGasPriceForChain" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getGasPriceForChain(chainId: number, speed: string, maxGasPrice: number): Promise<number | null>;

// Warning: (ae-internal-missing-underscore) The name "getMetadataWithoutContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getMetadataWithoutContract(provider: ProviderOrSigner, contractAddress: string, tokenId: string, ipfsGatewayUrl: string): Promise<NFTMetadata>;

// @public (undocumented)
export function getNativeTokenByChainId(chainId: ChainId): NativeToken;

// Warning: (ae-internal-missing-underscore) The name "getRoleHash" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getRoleHash(role: Role): BytesLike;

// Warning: (ae-internal-missing-underscore) The name "getTokenMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getTokenMetadata(contract: NFTContractTypes, tokenId: string, ipfsGatewayUrl: string): Promise<NFTMetadata>;

// @public (undocumented)
export function getTokenMetadataUsingStorage(contractAddress: string, provider: ProviderOrSigner, tokenId: string, storage: IStorage): Promise<NFTMetadata>;

// Warning: (ae-internal-missing-underscore) The name "getTokenUri" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getTokenUri(contract: NFTContractTypes, tokenId: string): Promise<string>;

// @public (undocumented)
export interface IAppModule {
    // (undocumented)
    address: string;
    // (undocumented)
    metadata?: ContractMetadata;
    // (undocumented)
    version: number;
}

// @public (undocumented)
export interface IDropModule {
    mintBatch(tokenMetadata: MetadataURIOrObject[]): Promise<void>;
}

// @public (undocumented)
export interface IMarketplaceModule {
    acceptDirectListingOffer(listingId: BigNumberish, addressOfOfferor: string): Promise<void>;
    buyoutAuctionListing(listingId: BigNumberish): Promise<void>;
    buyoutDirectListing(buyout: {
        listingId: BigNumberish;
        quantityDesired: BigNumberish;
    }): Promise<void>;
    buyoutListing(listingId: BigNumberish, quantityDesired?: BigNumberish): Promise<void>;
    cancelAuctionListing(listingId: BigNumberish): Promise<void>;
    cancelDirectListing(listingId: BigNumberish): Promise<void>;
    closeAuctionListing(listingId: BigNumberish, closeFor?: string): Promise<void>;
    createAuctionListing(listing: NewAuctionListing): Promise<BigNumber>;
    createDirectListing(listing: NewDirectListing): Promise<BigNumber>;
    getActiveOffer(listingId: BigNumberish, address: string): Promise<Offer | undefined>;
    getAllListings(): Promise<(AuctionListing | DirectListing)[]>;
    getAuctionListing(listingId: BigNumberish): Promise<AuctionListing>;
    getBidBufferBps(): Promise<BigNumber>;
    getDirectListing(listingId: BigNumberish): Promise<DirectListing>;
    getListing(listingId: BigNumberish): Promise<AuctionListing | DirectListing>;
    getTimeBufferInSeconds(): Promise<BigNumber>;
    getWinningBid(listingId: BigNumberish): Promise<Offer | undefined>;
    makeAuctionListingBid(bid: {
        listingId: BigNumberish;
        pricePerToken: BigNumberish;
    }): Promise<void>;
    makeDirectListingOffer(offer: {
        listingId: BigNumberish;
        quantityDesired: BigNumberish;
        currencyContractAddress: string;
        pricePerToken: BigNumberish;
    }): Promise<void>;
    setBidBufferBps(buffer: BigNumberish): Promise<void>;
    setTimeBufferInSeconds(buffer: BigNumberish): Promise<void>;
    updateAuctionListing(listing: AuctionListing): Promise<void>;
    updateDirectListing(listing: DirectListing): Promise<void>;
}

// @public (undocumented)
export interface INFTBundleBatchArgs {
    // (undocumented)
    amount: BigNumberish_2;
    // (undocumented)
    tokenId: BigNumberish_2;
}

// @beta (undocumented)
export interface INFTBundleCreateArgs {
    // (undocumented)
    metadata: MetadataURIOrObject;
    // (undocumented)
    supply: BigNumberish_2;
}

// @beta (undocumented)
export interface INFTCollectionBatchArgs {
    // (undocumented)
    amount: BigNumberish_2;
    // (undocumented)
    tokenId: BigNumberish_2;
}

// @public (undocumented)
export interface INFTCollectionCreateArgs {
    // (undocumented)
    metadata: MetadataURIOrObject;
    // (undocumented)
    supply: BigNumberish_2;
}

// Warning: (ae-internal-missing-underscore) The name "InterfaceId_IERC1155" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const InterfaceId_IERC1155: Uint8Array;

// Warning: (ae-internal-missing-underscore) The name "InterfaceId_IERC721" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const InterfaceId_IERC721: Uint8Array;

// @public
export class InvalidAddressError extends Error {
    // @internal
    constructor(address?: string);
}

// @public
export class InvariantError extends Error {
    // @internal
    constructor(message?: string);
    // @internal (undocumented)
    framesToPop: number;
    // @internal (undocumented)
    name: string;
}

// @beta (undocumented)
export interface IPackBatchArgs {
    // (undocumented)
    amount: BigNumberish;
    // (undocumented)
    tokenId: BigNumberish;
}

// @beta (undocumented)
export interface IPackCreateArgs {
    // (undocumented)
    assetContract: string;
    // (undocumented)
    assets: {
        tokenId: BigNumberish;
        amount: BigNumberish;
    }[];
    // (undocumented)
    metadata: MetadataURIOrObject;
    // (undocumented)
    rewardsPerOpen?: BigNumberish;
    // (undocumented)
    secondsUntilOpenStart?: BigNumberish;
}

// @public (undocumented)
export class IpfsStorage implements IStorage {
    constructor(gatewayUrl: string);
    // @internal
    batchUploadProperties(metadatas: MetadataURIOrObject[]): Promise<any>;
    buildFilePropertiesMap(object: Record<string, any>, files: (File | Buffer)[]): (File | Buffer)[];
    // (undocumented)
    get(hash: string): Promise<string>;
    // (undocumented)
    getUploadToken(contractAddress: string): Promise<string>;
    // @internal
    resolveFullUrl(ipfsHash: string): string;
    // (undocumented)
    upload(data: string | FileOrBuffer, contractAddress?: string, signerAddress?: string): Promise<string>;
    // Warning: (ae-forgotten-export) The symbol "BufferOrStringWithName" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    uploadBatch(files: Buffer[] | string[] | FileOrBuffer[] | File[] | BufferOrStringWithName[], contractAddress?: string, fileStartNumber?: number): Promise<string>;
    // (undocumented)
    uploadMetadata(metadata: MetadataURIOrObject, contractAddress?: string, _signerAddress?: string): Promise<string>;
    // @internal (undocumented)
    uploadMetadataBatch(metadatas: MetadataURIOrObject[], contractAddress?: string, startFileNumber?: number): Promise<UploadMetadataBatchResult>;
}

// @public
export interface IRoles {
    admin: "admin";
    // @alpha
    editor: "editor";
    lister: "lister";
    minter: "minter";
    pauser: "pauser";
    transfer: "transfer";
}

// Warning: (ae-internal-missing-underscore) The name "isContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function isContract(provider: Provider, address: string): Promise<boolean>;

// @public
export interface ISDKOptions {
    gasless: {
        biconomy: {
            apiId: string;
            apiKey: string;
            deadlineSeconds?: number;
        };
    };
    gaslessSendFunction: (contract: BaseContract, transaction: GaslessTransaction) => Promise<string>;
    gasSpeed: string;
    ipfsGatewayUrl: string;
    maxGasPriceInGwei: number;
    readOnlyRpcUrl: string;
    registryContractAddress: string;
    transactionRelayerForwarderAddress: string;
    // @deprecated (undocumented)
    transactionRelayerSendFunction: (message: ForwardRequestMessage | PermitRequestMessage, signature: BytesLike) => Promise<string>;
    transactionRelayerUrl: string;
}

// @public (undocumented)
export interface ISignatureMinter {
    generateSignature(mintRequest: NewSignaturePayload): Promise<{
        payload: SignaturePayload;
        signature: string;
    }>;
    generateSignatureBatch(payloads: NewSignaturePayload[]): Promise<{
        payload: SignaturePayload;
        signature: string;
    }[]>;
    mintWithSignature(req: SignaturePayload, signature: string): Promise<BigNumber>;
    verify(mintRequest: SignaturePayload, signature: string): Promise<boolean>;
}

// Warning: (ae-internal-missing-underscore) The name "isNativeToken" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function isNativeToken(tokenAddress: string): boolean;

// @public (undocumented)
export interface ISplitsModule {
    balanceOf(address: string): Promise<BigNumber>;
    balanceOfToken(walletAddress: string, tokenAddress: string): Promise<CurrencyValue>;
    distribute(): Promise<void>;
    distributeToken(tokenAddress: string): Promise<void>;
    getAllRecipients(): Promise<SplitRecipient[]>;
    getRecipientSplitPercentage(address: string): Promise<SplitRecipient>;
    withdraw(address: string): Promise<void>;
    withdrawToken(walletAddress: string, tokenAddress: string): Promise<void>;
}

// @public (undocumented)
export interface IStorage {
    get(hash: string): Promise<string>;
    getUploadToken(contractAddress: string): Promise<string>;
    resolveFullUrl(hash: string): string;
    upload(data: string | File | FileOrBuffer | Buffer, contractAddress?: string, signerAddress?: string): Promise<string>;
    uploadBatch(files: Buffer[] | string[] | FileOrBuffer[] | File[] | BufferOrStringWithName[], contractAddress?: string, uploadFileStartNumber?: number): Promise<string>;
    uploadMetadata(metadata: MetadataURIOrObject, contractAddress?: string, signerAddress?: string): Promise<string>;
    // Warning: (ae-incompatible-release-tags) The symbol "uploadMetadataBatch" is marked as @public, but its signature references "UploadMetadataBatchResult" which is marked as @internal
    uploadMetadataBatch(metadatas: MetadataURIOrObject[], contractAddress?: string, fileStartNumber?: number): Promise<UploadMetadataBatchResult>;
}

// @public (undocumented)
export interface IThirdwebSdk {
    // @beta
    createSnapshot(leafs: string[]): Promise<{
        merkleRoot: string;
        snapshotUri: string;
        snapshot: Snapshot;
    }>;
}

// @public (undocumented)
export interface ITokenMintArgs {
    // (undocumented)
    address: string;
    // (undocumented)
    amount: BigNumberish;
}

// @public (undocumented)
export interface ITokenMintFromArgs extends ITokenMintArgs {
    // (undocumented)
    fromAddress: string;
}

// @public (undocumented)
export interface ITransferable {
    isTransferRestricted(): Promise<boolean>;
    setRestrictedTransfer(restrict: boolean): Promise<TransactionReceipt>;
}

// @public
export type JSONValue = string | number | null | boolean | JSONValue[] | {
    [key: string]: JSONValue;
};

// @public
export class ListingNotFoundError extends Error {
    constructor(marketplaceContractAddress: string, listingId?: string);
}

// @public (undocumented)
export enum ListingType {
    // (undocumented)
    Auction = 1,
    // (undocumented)
    Direct = 0
}

// @public (undocumented)
export class MarketModuleMetadata extends CommonModuleMetadata {
    marketFeeBasisPoints: number;
}

// @public
export class MarketplaceModule extends ModuleWithRoles<Marketplace> implements IMarketplaceModule {
    // (undocumented)
    acceptDirectListingOffer(listingId: BigNumberish, addressOfOfferor: string): Promise<void>;
    buyoutAuctionListing(listingId: BigNumberish): Promise<void>;
    buyoutDirectListing(_buyout: {
        listingId: BigNumberish;
        quantityDesired: BigNumberish;
    }): Promise<void>;
    // (undocumented)
    buyoutListing(listingId: BigNumberish, quantityDesired?: BigNumberish): Promise<void>;
    cancelAuctionListing(listingId: BigNumberish): Promise<void>;
    cancelDirectListing(listingId: BigNumberish): Promise<void>;
    // (undocumented)
    closeAuctionListing(listingId: BigNumberish, closeFor?: string): Promise<void>;
    // @internal (undocumented)
    protected connectContract(): Marketplace;
    createAuctionListing(listing: NewAuctionListing): Promise<BigNumber>;
    createDirectListing(listing: NewDirectListing): Promise<BigNumber>;
    // (undocumented)
    getActiveOffer(listingId: BigNumberish, address: string): Promise<Offer | undefined>;
    getAllListings(): Promise<(AuctionListing | DirectListing)[]>;
    // (undocumented)
    getAuctionListing(listingId: BigNumberish): Promise<AuctionListing>;
    // (undocumented)
    getBidBufferBps(): Promise<BigNumber>;
    // (undocumented)
    getDirectListing(listingId: BigNumberish): Promise<DirectListing>;
    // (undocumented)
    getListing(listingId: BigNumberish): Promise<AuctionListing | DirectListing>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getTimeBufferInSeconds(): Promise<BigNumber>;
    // (undocumented)
    getWinningBid(listingId: BigNumberish): Promise<Offer | undefined>;
    // (undocumented)
    isWinningBid(winningPrice: BigNumberish, newBidPrice: BigNumberish, bidBuffer: BigNumberish): Promise<boolean>;
    makeAuctionListingBid(bid: {
        listingId: BigNumberish;
        pricePerToken: BigNumberish;
    }): Promise<void>;
    // (undocumented)
    makeDirectListingOffer(offer: {
        listingId: BigNumberish;
        quantityDesired: BigNumberish;
        currencyContractAddress: string;
        pricePerToken: BigNumberish;
    }): Promise<void>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "lister"];
    // (undocumented)
    setBidBufferBps(buffer: BigNumberish): Promise<void>;
    // (undocumented)
    setTimeBufferInSeconds(buffer: BigNumberish): Promise<void>;
    // (undocumented)
    updateAuctionListing(listing: AuctionListing): Promise<void>;
    // (undocumented)
    updateDirectListing(listing: DirectListing): Promise<void>;
}

// @public (undocumented)
export class MarketplaceModuleMetadata extends CommonModuleMetadata {
    marketFeeBasisPoints: number;
}

// @public
export type MetadataURIOrObject = string | Record<string, any>;

// @public (undocumented)
export class MissingOwnerRoleError extends Error {
    // @internal
    constructor();
}

// @public (undocumented)
export class MissingRoleError extends Error {
    // @internal
    constructor(address: string, role: string);
}

// @public
export class Module<TContract extends BaseContract = BaseContract> {
    // @internal
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    // (undocumented)
    readonly address: string;
    // @internal (undocumented)
    clearSigner(): void;
    // @internal @virtual (undocumented)
    protected connectContract(): TContract;
    // @internal
    contract: TContract;
    // (undocumented)
    exists(): Promise<boolean>;
    // @internal (undocumented)
    protected getCallOverrides(): Promise<CallOverrides>;
    // @internal (undocumented)
    protected getChainID(): Promise<number>;
    getMetadata(resolveUrls?: boolean): Promise<ModuleMetadata>;
    // @internal @virtual (undocumented)
    protected getModuleType(): ModuleType;
    // @internal (undocumented)
    protected getProvider(): Promise<ethers.providers.Provider>;
    // @internal (undocumented)
    protected getSigner(): Signer | null;
    // @internal (undocumented)
    protected getSignerAddress(): Promise<string>;
    // @internal (undocumented)
    protected hasValidSigner(): boolean;
    // @internal (undocumented)
    protected readonly ipfsGatewayUrl: string;
    // @internal (undocumented)
    protected readonly options: ISDKOptions;
    // (undocumented)
    protected parseEventLogs(eventName: string, logs?: Log[]): any;
    // (undocumented)
    protected parseLogs<T = any>(eventName: string, logs?: Log[], contract?: BaseContract): T[];
    // @internal (undocumented)
    protected get providerOrSigner(): ProviderOrSigner;
    // @internal
    readOnlyContract: TContract;
    // (undocumented)
    protected readonly sdk: ThirdwebSDK;
    // @internal (undocumented)
    protected sendContractTransaction(contract: BaseContract, fn: string, args: any[], callOverrides?: CallOverrides): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected sendTransaction(fn: string, args: any[], callOverrides?: CallOverrides): Promise<TransactionReceipt>;
    setMetadata(metadata: MetadataURIOrObject): Promise<ModuleMetadata>;
    // @internal (undocumented)
    setProviderOrSigner(providerOrSigner: ProviderOrSigner): void;
    // @internal (undocumented)
    protected get signer(): Signer | null;
    // (undocumented)
    protected signTypedData(signer: ethers.Signer, from: string, domain: {
        name: string;
        version: string;
        chainId: number;
        verifyingContract: string;
    }, types: any, message: any): Promise<BytesLike>;
}

// @public
export interface ModuleMetadata {
    // (undocumented)
    address: string;
    // (undocumented)
    metadata?: ContractMetadata;
    // (undocumented)
    type: ModuleType;
}

// @public
export type ModuleType = "TOKEN" | "NFT_COLLECTION" | "BUNDLE_COLLECTION" | "PACK" | "NFT_DROP" | "BUNDLE_DROP" | "VOTE" | "SPLITS" | "MARKETPLACE";

// @public
export class ModuleWithRoles<TContract extends BaseContract> extends Module<TContract> {
    // @internal
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    getAllRoleMembers(): Promise<Partial<Record<Role, string[]>>>;
    // @internal @virtual (undocumented)
    protected getModuleRoles(): readonly Role[];
    getRoleMembers(role: Role): Promise<string[]>;
    grantRole(role: Role, address: string): Promise<TransactionReceipt>;
    protected onlyRoles(roles: Role[], address: string): Promise<void>;
    prepareBatchMetadata(metadata: MetadataURIOrObject[]): Promise<string[]>;
    prepareMetadata(metadata: MetadataURIOrObject): Promise<string>;
    revokeAllRolesFromAddress(address: string): Promise<Role[]>;
    revokeRole(role: Role, address: string): Promise<TransactionReceipt>;
    setAllRoleMembers(rolesWithAddresses: SetAllRoles): Promise<any>;
}

// Warning: (ae-internal-missing-underscore) The name "NATIVE_TOKEN_ADDRESS" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";

// @public (undocumented)
export interface NativeToken extends Currency {
    // (undocumented)
    wrapped: {
        address: string;
        name: string;
        symbol: string;
    };
}

// @public
export interface NewAuctionListing {
    assetContractAddress: string;
    buyoutPricePerToken: BigNumberish;
    currencyContractAddress: string;
    listingDurationInSeconds: BigNumberish;
    quantity: BigNumberish;
    reservePricePerToken: BigNumberish;
    startTimeInSeconds: BigNumberish;
    tokenId: BigNumberish;
    // (undocumented)
    type?: "NewAuctionListing";
}

// @public
export interface NewDirectListing {
    assetContractAddress: string;
    buyoutPricePerToken: BigNumberish;
    currencyContractAddress: string;
    listingDurationInSeconds: BigNumberish;
    quantity: BigNumberish;
    startTimeInSeconds: BigNumberish;
    tokenId: BigNumberish;
    // (undocumented)
    type?: "NewDirectListing";
}

// @public
export interface NewSignaturePayload {
    currencyAddress: string;
    id?: string;
    metadata: MetadataURIOrObject;
    mintEndTimeEpochSeconds: BigNumberish;
    mintStartTimeEpochSeconds: BigNumberish;
    price: BigNumberish;
    to: string;
}

// @public
export interface NewSplitRecipient {
    address: string;
    shares: BigNumberish;
}

// Warning: (ae-internal-missing-underscore) The name "NFTContractTypes" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type NFTContractTypes = SignatureMint721 | NFTCollection | LazyMintERC721 | LazyMintERC1155;

// @public
export interface NFTMetadata {
    // (undocumented)
    animation_url?: string;
    // (undocumented)
    description?: string;
    // (undocumented)
    external_url?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    image?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    properties?: Record<string, JSONValue>;
    // (undocumented)
    uri: string;
}

// @public
export interface NFTMetadataOwner {
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    owner: string;
}

// @public
export class NFTModule extends ModuleWithRoles<SignatureMint721> implements ITransferable, ISignatureMinter {
    // (undocumented)
    balance(): Promise<BigNumber>;
    balanceOf(address: string): Promise<BigNumber>;
    burn(tokenId: BigNumberish): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): SignatureMint721;
    // (undocumented)
    generateSignature(mintRequest: NewSignaturePayload): Promise<{
        payload: SignaturePayload;
        signature: string;
    }>;
    // (undocumented)
    generateSignatureBatch(payloads: NewSignaturePayload[]): Promise<{
        payload: SignaturePayload;
        signature: string;
    }[]>;
    get(tokenId: string): Promise<NFTMetadata>;
    getAll(): Promise<NFTMetadata[]>;
    // (undocumented)
    getAllWithOwner(): Promise<NFTMetadataOwner[]>;
    // (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    getOwned(_address?: string): Promise<NFTMetadata[]>;
    getRoyaltyBps(): Promise<BigNumberish>;
    getRoyaltyRecipientAddress(): Promise<string>;
    // (undocumented)
    getWithOwner(tokenId: string): Promise<NFTMetadataOwner>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    isTransferRestricted(): Promise<boolean>;
    // (undocumented)
    mint(metadata: MetadataURIOrObject): Promise<NFTMetadata>;
    // (undocumented)
    mintBatch(metadatas: MetadataURIOrObject[]): Promise<NFTMetadata[]>;
    mintBatchTo(to: string, metadatas: MetadataURIOrObject[]): Promise<NFTMetadata[]>;
    mintTo(to: string, metadata: MetadataURIOrObject): Promise<NFTMetadata>;
    // (undocumented)
    mintWithSignature(req: SignaturePayload, signature: string): Promise<BigNumber>;
    // (undocumented)
    static moduleType: ModuleType;
    ownerOf(tokenId: string): Promise<string>;
    // (undocumented)
    static roles: readonly ["admin", "minter", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    // (undocumented)
    totalSupply(): Promise<BigNumber>;
    transfer(to: string, tokenId: string): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, tokenId: BigNumberish): Promise<TransactionReceipt>;
    // (undocumented)
    verify(mintRequest: SignaturePayload, signature: string): Promise<boolean>;
}

// @public (undocumented)
export class NftModuleMetadata extends CommonModuleMetadata {
    defaultSaleRecipientAddress?: string | undefined;
    feeRecipient?: string;
    primarySaleFeeBasisPoints?: number | undefined;
    sellerFeeBasisPoints: number;
    symbol?: string;
}

// @public (undocumented)
export class NotEnoughTokensError extends Error {
    // @internal
    constructor(contractAddress: string, quantity: number, available: number);
}

// @public
export class NotFoundError extends Error {
    // @internal
    constructor();
}

// @public (undocumented)
export interface Offer {
    buyerAddress: string;
    currencyContractAddress: string;
    currencyValue: CurrencyValue;
    listingId: BigNumberish;
    pricePerToken: BigNumber;
    quantityDesired: BigNumberish;
}

// @beta (undocumented)
export interface PackMetadata {
    // (undocumented)
    creator: string;
    // (undocumented)
    currentSupply: BigNumber;
    // (undocumented)
    id: string;
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    openStart: Date | null;
}

// @public
export class PackModule extends ModuleWithRoles<Pack> implements ITransferable {
    // (undocumented)
    balance(tokenId: string): Promise<BigNumber>;
    balanceOf(address: string, tokenId: string): Promise<BigNumber>;
    // @internal (undocumented)
    protected connectContract(): Pack_2;
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "IPackCreateArgs" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "PackMetadata" which is marked as @beta
    create(args: IPackCreateArgs): Promise<PackMetadata>;
    // (undocumented)
    depositLink(amount: BigNumberish): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "get" is marked as @public, but its signature references "PackMetadata" which is marked as @beta
    //
    // (undocumented)
    get(packId: string): Promise<PackMetadata>;
    // Warning: (ae-incompatible-release-tags) The symbol "getAll" is marked as @public, but its signature references "PackMetadata" which is marked as @beta
    getAll(): Promise<PackMetadata[]>;
    // (undocumented)
    getLinkBalance(): Promise<CurrencyValue>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    getNFTs(packId: string): Promise<PackNFTMetadata[]>;
    getRoyaltyBps(): Promise<BigNumberish>;
    getRoyaltyRecipientAddress(): Promise<string>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    isTransferRestricted(): Promise<boolean>;
    // (undocumented)
    static moduleType: ModuleType;
    open(packId: string): Promise<NFTMetadata[]>;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<void>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<void>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    transfer(to: string, tokenId: string, amount: BigNumber): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "transferBatchFrom" is marked as @public, but its signature references "IPackBatchArgs" which is marked as @beta
    //
    // (undocumented)
    transferBatchFrom(from: string, to: string, args: IPackBatchArgs[], data?: BytesLike): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "transferFrom" is marked as @public, but its signature references "IPackBatchArgs" which is marked as @beta
    //
    // (undocumented)
    transferFrom(from: string, to: string, args: IPackBatchArgs, data?: BytesLike): Promise<void>;
    // (undocumented)
    withdrawLink(to: string, amount: BigNumberish): Promise<void>;
}

// @public (undocumented)
export class PackModuleMetadata extends CommonModuleMetadata {
    feeRecipient?: string;
    sellerFeeBasisPoints: number;
}

// @public (undocumented)
export interface PackNFTMetadata {
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    supply: BigNumber;
}

// @public
export type PermitRequestMessage = {
    to: string;
    owner: string;
    spender: string;
    value: number | string;
    nonce: number | string;
    deadline: number | string;
};

// @public (undocumented)
export interface Proposal {
    description: string;
    // (undocumented)
    endBlock: BigNumber;
    executions: ProposalExecutable[];
    proposalId: string;
    proposer: string;
    // (undocumented)
    startBlock: BigNumber;
    state: ProposalState;
    votes: ProposalVote[];
}

// @public (undocumented)
export interface ProposalExecutable {
    nativeTokenValue: BigNumberish;
    toAddress: string;
    transactionData: BytesLike;
}

// @public (undocumented)
export enum ProposalState {
    // (undocumented)
    Active = 1,
    // (undocumented)
    Canceled = 2,
    // (undocumented)
    Defeated = 3,
    // (undocumented)
    Executed = 7,
    // (undocumented)
    Expired = 6,
    // (undocumented)
    Pending = 0,
    // (undocumented)
    Queued = 5,
    // (undocumented)
    Succeeded = 4
}

// @public (undocumented)
export interface ProposalVote {
    // (undocumented)
    count: BigNumber;
    // (undocumented)
    label: string;
    // (undocumented)
    type: VoteType;
}

// @public
export type ProviderOrSigner = Provider | Signer;

// @public (undocumented)
export interface PublicClaimCondition {
    // (undocumented)
    currency: string;
    // (undocumented)
    currentMintSupply: BigNumberish;
    // (undocumented)
    maxMintSupply: BigNumberish;
    // (undocumented)
    merkleRoot: BytesLike;
    // (undocumented)
    pricePerToken: BigNumberish;
    // (undocumented)
    quantityLimitPerTransaction: BigNumberish;
    // (undocumented)
    startTimestamp: BigNumber;
    // (undocumented)
    waitTimeSecondsLimitPerTransaction: BigNumberish;
}

// @public (undocumented)
export class QuantityAboveLimitError extends Error {
    // @internal
    constructor(quantity: string);
}

// @public (undocumented)
export function recursiveResolveGatewayUrl(json: any, ipfsGatewayUrl: string): any;

// Warning: (ae-internal-missing-underscore) The name "replaceIpfsWithGateway" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function replaceIpfsWithGateway(ipfsUrl: string, gatewayUrl: string): string;

// @public
export class RestrictedTransferError extends Error {
    constructor(assetAddress?: string);
}

// @public
export type Role = keyof IRoles;

// Warning: (ae-internal-missing-underscore) The name "RolesMap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const RolesMap: IRoles;

// @public (undocumented)
export type SetAllRoles = {
    [key in keyof IRoles]?: string[];
};

// @public
export interface SignaturePayload extends NewSignaturePayload {
    uri: string;
}

// @public (undocumented)
export class Snapshot {
    // (undocumented)
    claims: ClaimProof[];
    // (undocumented)
    merkleRoot: string;
}

// @public (undocumented)
export interface SnapshotInfo {
    // (undocumented)
    merkleRoot: string;
    // (undocumented)
    snapshot: Snapshot;
    // (undocumented)
    snapshotUri: string;
}

// @public
export interface SplitRecipient {
    address: string;
    splitPercentage: number;
}

// @public
export class SplitsModule extends Module<Splits> implements ISplitsModule {
    balanceOf(address: string): Promise<BigNumber>;
    balanceOfAllRecipients(): Promise<{
        [key: string]: BigNumber;
    }>;
    balanceOfToken(walletAddress: string, tokenAddress: string): Promise<CurrencyValue>;
    balanceOfTokenAllRecipients(tokenAddress: string): Promise<{
        [key: string]: CurrencyValue;
    }>;
    // @internal (undocumented)
    protected connectContract(): Splits;
    distribute(): Promise<void>;
    distributeToken(tokenAddress: string): Promise<void>;
    // (undocumented)
    get(): Promise<Currency>;
    getAllRecipients(): Promise<SplitRecipient[]>;
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getRecipientSplitPercentage(address: string): Promise<SplitRecipient>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    withdraw(address: string): Promise<void>;
    // (undocumented)
    withdrawToken(walletAddress: string, tokenAddress: string): Promise<void>;
}

// @public (undocumented)
export class SplitsModuleMetadata extends CommonModuleMetadata {
    // (undocumented)
    recipientSplits: NewSplitRecipient[];
}

// @public
export class ThirdwebSDK implements IThirdwebSdk {
    constructor(providerOrNetwork: ValidProviderInput, opts?: Partial<ISDKOptions>);
    // (undocumented)
    createSnapshot(leafs: string[]): Promise<SnapshotInfo>;
    // (undocumented)
    getBundleCollectionModule(address: string): BundleCollectionModule;
    // @beta (undocumented)
    getBundleDropModule(address: string): BundleDropModule;
    // (undocumented)
    getDropModule(address: string): DropModule;
    // (undocumented)
    getGasPrice(speed?: string, maxGasGwei?: number): Promise<number | null>;
    // @beta (undocumented)
    getMarketplaceModule(address: string): MarketplaceModule;
    getModules(address: string, filterByModuleType?: ModuleType[]): Promise<ModuleMetadata[]>;
    // (undocumented)
    getNFTModule(address: string): NFTModule;
    // (undocumented)
    getPackModule(address: string): PackModule;
    // @alpha (undocumented)
    getSplitsModule(address: string): SplitsModule;
    getStorage(): IStorage;
    // (undocumented)
    getTokenModule(address: string): TokenModule;
    // @alpha (undocumented)
    getVoteModule(address: string): VoteModule;
    // @internal
    invokeRoute(route: string, payload: Record<string, any>): any;
    // (undocumented)
    isReadOnly(): boolean;
    overrideStorage(storage: IStorage): void;
    // (undocumented)
    setProviderOrSigner(providerOrSignerOrNetwork: ValidProviderInput): ProviderOrSigner;
    // @internal
    get signer(): Signer | null;
}

// @public
export class TokenModule extends ModuleWithRoles<Coin> implements ITransferable {
    // (undocumented)
    allowance(spender: string): Promise<BigNumber>;
    allowanceOf(owner: string, spender: string): Promise<BigNumber>;
    // (undocumented)
    balance(): Promise<CurrencyValue>;
    balanceOf(address: string): Promise<CurrencyValue>;
    burn(amount: BigNumberish): Promise<TransactionReceipt>;
    // (undocumented)
    burnFrom(from: string, amount: BigNumberish): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): Coin;
    // @alpha
    delegateTo(delegateeAddress: string): Promise<TransactionReceipt>;
    // (undocumented)
    get(): Promise<Currency>;
    // @beta
    getAllHolderBalances(): Promise<Record<string, BigNumber>>;
    getDelegation(): Promise<string>;
    // (undocumented)
    getDelegationOf(account: string): Promise<string>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getValue(value: BigNumberish): Promise<CurrencyValue>;
    getVoteBalance(): Promise<BigNumber>;
    // (undocumented)
    getVoteBalanceOf(account: string): Promise<BigNumber>;
    // (undocumented)
    isTransferRestricted(): Promise<boolean>;
    // (undocumented)
    mint(amount: BigNumberish): Promise<void>;
    mintBatchTo(args: ITokenMintArgs[]): Promise<void>;
    mintTo(to: string, amount: BigNumberish): Promise<void>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setAllowance(spender: string, amount: BigNumber): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    totalSupply(): Promise<BigNumber>;
    transfer(to: string, amount: BigNumberish): Promise<TransactionReceipt>;
    // (undocumented)
    transferBatch(args: ITokenMintArgs[]): Promise<void>;
    transferFrom(from: string, to: string, amount: BigNumberish): Promise<TransactionReceipt>;
    // (undocumented)
    transferFromBatch(args: ITokenMintFromArgs[]): Promise<void>;
}

// @public (undocumented)
export class TokenModuleMetadata extends CommonModuleMetadata {
    symbol: string;
}

// @public (undocumented)
export enum UnderlyingType {
    // (undocumented)
    ERC20 = 1,
    // (undocumented)
    ERC721 = 2,
    // (undocumented)
    None = 0
}

// @public (undocumented)
export class UploadError extends Error {
    // @internal
    constructor(message: string);
}

// Warning: (ae-internal-missing-underscore) The name "uploadMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function uploadMetadata(metadata: MetadataURIOrObject, contractAddress?: string, signerAddress?: string): Promise<string>;

// Warning: (ae-internal-missing-underscore) The name "UploadMetadataBatchResult" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface UploadMetadataBatchResult {
    // (undocumented)
    baseUri: string;
    // (undocumented)
    metadataUris: string[];
}

// @public
export function uploadToIPFS(data: string | File | FileOrBuffer, contractAddress?: string, signerAddress?: string): Promise<string>;

// @public
export type ValidProviderInput = ProviderOrSigner | Network | string;

// @public
export class VoteModule extends Module<VotingGovernor> {
    balance(): Promise<CurrencyValue>;
    balanceOfToken(tokenAddress: string): Promise<CurrencyValue>;
    canExecute(proposalId: string): Promise<boolean>;
    // @internal (undocumented)
    protected connectContract(): VotingGovernor;
    execute(proposalId: string): Promise<void>;
    get(proposalId: string): Promise<Proposal>;
    getAll(): Promise<Proposal[]>;
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    hasVoted(proposalId: string, account?: string): Promise<boolean>;
    // (undocumented)
    static moduleType: ModuleType;
    propose(description: string, executions?: ProposalExecutable[]): Promise<BigNumber>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    settings(): Promise<VoteSettings>;
    vote(proposalId: string, voteType: VoteType, reason?: string): Promise<void>;
}

// @public (undocumented)
export class VoteModuleMetadata extends CommonModuleMetadata {
    minimumNumberOfTokensNeededToPropose: string;
    proposalStartWaitTimeInSeconds: number;
    proposalVotingTimeInSeconds: number;
    votingDelay?: number | undefined;
    votingPeriod?: number | undefined;
    votingQuorumFraction: number;
    votingTokenAddress: string;
}

// @public (undocumented)
export interface VoteSettings {
    // (undocumented)
    proposalTokenThreshold: string;
    // (undocumented)
    votingDelay: string;
    // (undocumented)
    votingPeriod: string;
    // (undocumented)
    votingQuorumFraction: string;
    // (undocumented)
    votingTokenAddress: string;
    // (undocumented)
    votingTokenMetadata: Currency;
}

// @public (undocumented)
export enum VoteType {
    // (undocumented)
    Abstain = 2,
    // (undocumented)
    Against = 0,
    // (undocumented)
    For = 1
}

// @public
export class WrongListingTypeError extends Error {
    constructor(marketplaceContractAddress: string, listingId?: string, actualType?: string, expectedType?: string);
}

```
